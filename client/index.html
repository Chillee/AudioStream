<!doctype html>
<html>
	<head>
	    <meta charset="utf-8">
	    <meta name="viewport" content="width=620"/>
	    <title>WebRTC Demo: Stream your mp3s</title>
	    <script src="/js/adapter.js"></script>
		<script src="/socket.io/socket.io.js"></script>
		<script src="/js/id3-minimized.js"></script>
		<script src="https://apis.google.com/js/client.js?onload=load"></script>
		<link rel="shortcut icon" type="image/x-icon" href="http://www.tno.nl/favicon_tno.ico"/>
		<link rel="stylesheet" href="/res/tnortc.css" type="text/css"/>
		<style>
			#holder { border: 10px dashed #ccc; width: 300px; height: 300px; margin: 20px auto;}
			#holder.hover { border: 10px dashed #333; }
			#holder.background { background-size:100% 100%; background-repeat:no-repeat;}
		</style>
	</head>

	<body>
		<div id="blocktop">
			<span id="label99"/>
		</div>
		<div id="blockbanner-back">
			<div id="blockbanner"></div>
		</div>
		<div id="blockcontent">
			<article style="align: center;">
				<h1>Stream mp3s directly from your browser</h1>

				<div id="holder"></div> 

				<div style="text-align: center">
					<input type="button" onclick="toggleMute();" value="Mute/Unmute" class="button"/>
					<input type="button" onclick="togglePlay();" value="Pause/Play" class="button"/>
					<br/>
					<label>Volume</label>
					<input type="range" min="0" max="100" value="100" oninput="changeVolume(this);" class="button" style="vertical-align: middle"/>
					<h3>You have <span id="counter">0</span> listeners.</h3>
					<h4 id="room">
					</h4>
				</div>

				<p id="status">The required APIs are not supported by your browser. Please try again using <a href="http://www.google.com/chrome">Chrome</a>.</p>
				<p>Drag an mp3 to the drop zone above to stream it to your friends without uploading the file to any servers.</p>
			</article>
		</div>
	</body>

    <script lang="javascript">
    	var holder = document.getElementById('holder');
    	var state = document.getElementById('status');
    	var room = document.getElementById('room');
    	var counter = document.getElementById('counter');

		// Check for the various File API support.

		if (window.File
			&& window.FileReader 
			&& window.FileList 
			&& window.Blob
			&& RTCPeerConnection
			&& (window.AudioContext || window.webkitAudioContext)) {
			window.AudioContext = window.AudioContext || window.webkitAudioContext;
			state.className = 'success';
			state.innerHTML = 'All the required APIs are available.'
		} else {
			state.className = 'fail';
		}

		// handle file drops

		holder.ondragover = function () { this.className = 'hover'; return false; };
		holder.ondragend = function () { this.className = ''; return false; };
		holder.ondrop = handleFileDrop;

		var socket = io.connect();

		var context = new AudioContext();
		var currentStream;

		var pc_config = {"iceServers": [{"url": "stun:stun.l.google.com:19302"}]};

		var peers = {};
		var myId;

		var gainNode = context.createGain();
		gainNode.connect(context.destination);
		var mediaSource, mediaBuffer, remoteDestination, mediaDescription;
		var muted, start, stop;

		socket.on('your-id', function(id) {
			myId = id;
			console.log('id = ' + id);

			var clientURL = window.location.protocol + '//' + window.location.host + '/client.html?id=' + myId;
			room.innerHTML = 'Invite other to listen to your stream by sharing this link:<br/><a href="' + clientURL + '" target="_blank">' + clientURL + '</a>'; 
		});

		socket.on('disconnected', function(from) {
			peers[from] = undefined;
		});

		socket.on('logon', function(message) {
			pc = new RTCPeerConnection(pc_config, { optional: [ { RtpDataChannels: true } ]});
			
			pc.onicecandidate = function(event) {
				socket.emit('message', { from: myId, to: message.from, data: { type: 'candidate', candidate: event.candidate } } );
			}

			peers[message.from] = { peerconnection: pc, stream: undefined };
			startPlayingIfPossible(message.from);

			counter.innerHTML = parseInt(counter.innerHTML, 10) + 1;
		});

		socket.on('message', function(message) {
			console.log('Received message: ' + JSON.stringify(message.data));

			if (message.data.type === 'candidate') {
				if (message.data.candidate) {
					peers[message.from].peerconnection.addIceCandidate(new RTCIceCandidate(message.data.candidate));
				}
			} else if (message.data.type === 'sdp') {
				peers[message.from].peerconnection.setRemoteDescription(new RTCSessionDescription(message.data.sdp));
			}
		});

		function gotDescription(from, desc) {
			peers[from].peerconnection.setLocalDescription(desc);
			socket.emit('message', { from: myId, to: from, data: { type: 'sdp', sdp: desc } });
		}

		function startPlayingIfPossible(from) {
			// add the stream to the peerconnection for this connection
			if (mediaSource && remoteDestination) {
				peers[from].peerconnection.addStream(remoteDestination.stream);
				peers[from].stream = remoteDestination.stream;
				peers[from].peerconnection.createOffer(function(desc) {
					gotDescription(from, desc)
				}, failed);

				// send the mediaDescription via a datachannel if present
				if (mediaDescription) {
					if (!peers[from].dataChannel) {
						peers[from].dataChannel = peers[from].peerconnection.createDataChannel('mediaDescription', { reliable: false });
						peers[from].dataChannel.onopen = onDataChannelOpen;
						peers[from].peerconnection.createOffer(function(desc) {
							gotDescription(from, desc)
						}, failed);
					} else {
						if (peers[from].dataChannel.readyState === 'open') {
							sendMediaDescription(peers[from].dataChannel);
						}
					}

				}
			}
		}

		function sendMediaDescription(channel) {
			if (channel.readyState === 'open') {
				var data = JSON.stringify(mediaDescription);
				channel.send(data);
			}
		}

		function onDataChannelOpen() {
			sendMediaDescription(this);
		}

		function failed(code) {
    		log("Failure callback: " + code);
  		}

    	function handleFileDrop(event) {
    		stopStream();

			this.className = '';
			event.preventDefault();

			var file = event.dataTransfer.files[0];
			mediaDescription = {};

			ID3.loadTags(file.name, function() {
			    var tags = ID3.getAllTags(file.name);
			    console.log(tags.artist + " - " + tags.title + ", " + tags.album);

			    mediaDescription.artist = tags.artist;
			    mediaDescription.title = tags.title;

			    if ('picture' in tags) {
			    	var image = tags.picture;

			    	// mediaDescription.image = {};
			    	// mediaDescription.image.format = image.format;
			    	// mediaDescription.image.base64 = Base64.encodeBytes(image.data);

			    	holder.style.background = 'url("data:' + image.format + ';base64,' + Base64.encodeBytes(image.data) + '") no-repeat center';
			    	holder.style.backgroundSize = "295px 295px";
			    }
			}, { 
				tags: ["artist", "title", "album", "year", "comment", "track", "genre", "lyrics", "picture"],
				dataReader: new FileAPIReader(file)
			});

			if (file.type.match('audio*')) {
				var reader = new FileReader();

				reader.onload = (function(readEvent) {
					// holder.style.background = 'url(' + event.target.result + ') no-repeat center';
					context.decodeAudioData(readEvent.target.result, function(buffer) {
						if (mediaSource) {
							mediaSource.stop(0);
						}

						mediaBuffer = buffer;
						playStream();
						start = Date.now();
					});
				});

				reader.readAsArrayBuffer(file);
			}

			return false;
		}

    	function playStream(offset) {
    		offset = offset ? offset : 0;
			mediaSource = context.createBufferSource();
			mediaSource.buffer = mediaBuffer;
			mediaSource.start(0, offset / 1000);
			mediaSource.connect(gainNode);

			// setup remote stream
			remoteDestination = context.createMediaStreamDestination();
			mediaSource.connect(remoteDestination);

			for (var peer in peers) {
				startPlayingIfPossible(peer);
			}
    	}

    	function stopStream() {
    		for (var peer in peers) {
    			if (peers[peer].stream) {
	    			peers[peer].peerconnection.removeStream(peers[peer].stream);
	    			peers[peer].stream = undefined;
    			}
    		}

    		if (mediaSource) mediaSource.stop(0);
    	}

    	function changeVolume(element) {
    		var volume = element.value;
    		var fraction = parseInt(element.value, 10) / parseInt(element.max, 10);
    		gainNode.gain.value = fraction * fraction;
    	}

    	function toggleMute() {
    		if (muted) {
    			gainNode.gain.value = muted;
    			muted = undefined;
    		} else {
    			muted = gainNode.gain.value;
    			gainNode.gain.value = 0;
    		}
    	}

    	function togglePlay() {
    		if (stop) {
    			var offset = stop - start;
    			playStream(offset);
    			start = Date.now() - offset;
    			stop = undefined;
    		} else {
    			stopStream(offset);
    			stop = Date.now();
    		} 
    	}
    </script>

</html>